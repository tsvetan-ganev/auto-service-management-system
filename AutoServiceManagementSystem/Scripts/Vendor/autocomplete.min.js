// JavaScript autoComplete v1.0.0 beta
// https://github.com/Pixabay/JavaScript-autoComplete
var autoComplete = function () { function e(e) { function t(e, t) { return e.classList ? e.classList.contains(t) : new RegExp("\\b" + t + "\\b").test(e.className) } function s(e, t) { if (document.createEvent) { var s = document.createEvent("HTMLEvents"); s.initEvent(t, !0, !0), e.dispatchEvent(s) } else { var s = document.createEventObject(); s.eventType = t, e.fireEvent("on" + s.eventType, s) } } function o(e, t, s) { e.attachEvent ? e.attachEvent("on" + t, s) : e.addEventListener(t, s) } function n(e, t, s) { e.detachEvent ? e.detachEvent("on" + t, s) : e.removeEventListener(t, s) } function c(e, s, n, c) { o(c || document, s, function (s) { for (var o, c = s.target || s.srcElement; c && !(o = t(c, e)) ;) c = c.parentElement; o && n.call(c, s) }) } if (document.querySelector) { var l = { selector: 0, source: 0, minChars: 3, delay: 150, cache: 1, menuClass: "", renderItem: function (e, t) { var s = new RegExp("(" + t.split(" ").join("|") + ")", "gi"); return '<div class="autocomplete-suggestion" data-val="' + e + '">' + e.replace(s, "<b>$1</b>") + "</div>" }, onSelect: function (e, t, s) { } }; for (var a in e) e.hasOwnProperty(a) && (l[a] = e[a]); for (var u = "object" == typeof l.selector ? [l.selector] : document.querySelectorAll(l.selector), i = 0; i < u.length; i++) { var r = u[i]; r.sc = document.createElement("div"), r.sc.className = "autocomplete-suggestions " + l.menuClass, r.setAttribute("data-sc", r.sc), r.autocompleteAttr = r.getAttribute("autocomplete"), r.setAttribute("autocomplete", "off"), r.cache = {}, r.last_val = "", r.updateSC = function (e, t) { var s = r.getBoundingClientRect(); if (r.sc.style.left = s.left + (window.pageXOffset || document.documentElement.scrollLeft) + "px", r.sc.style.top = s.bottom + (window.pageYOffset || document.documentElement.scrollTop) + 1 + "px", r.sc.style.width = s.right - s.left + "px", !e && (r.sc.style.display = "block", r.sc.maxHeight || (r.sc.maxHeight = parseInt((window.getComputedStyle ? getComputedStyle(r.sc, null) : r.sc.currentStyle).maxHeight)), r.sc.suggestionHeight || (r.sc.suggestionHeight = r.sc.querySelector(".autocomplete-suggestion").offsetHeight), r.sc.suggestionHeight)) if (t) { var o = r.sc.scrollTop, n = t.getBoundingClientRect().top - r.sc.getBoundingClientRect().top; n + r.sc.suggestionHeight - r.sc.maxHeight > 0 ? r.sc.scrollTop = n + r.sc.suggestionHeight + o - r.sc.maxHeight : 0 > n && (r.sc.scrollTop = n + o) } else r.sc.scrollTop = 0 }, o(window, "resize", r.updateSC), document.body.appendChild(r.sc), c("autocomplete-suggestion", "mouseleave", function (e) { var t = r.sc.querySelector(".autocomplete-suggestion.selected"); t && setTimeout(function () { t.className = t.className.replace("selected", "") }, 20) }, r.sc), c("autocomplete-suggestion", "mouseover", function (e) { var t = r.sc.querySelector(".autocomplete-suggestion.selected"); t && (t.className = t.className.replace("selected", "")), this.className += " selected" }, r.sc), c("autocomplete-suggestion", "mouseup", function (e) { if (t(this, "autocomplete-suggestion")) { var s = this.getAttribute("data-val"); r.value = s, l.onSelect(e, s, this), r.focus(), r.sc.style.display = "none" } }, r.sc), r.blurHandler = function () { try { var e = document.querySelector(".autocomplete-suggestions:hover") } catch (t) { var e = 0 } e ? r.focus() : (r.last_val = r.value, r.sc.style.display = "none") }, o(r, "blur", r.blurHandler), r.focusHandler = function () { r.last_val = "\n", s(r, "keyup") }, l.minChars || o(r, "focus", r.focusHandler); var d = function (e) { var t = r.value; if (r.cache[t] = e, e.length && t.length >= l.minChars) { for (var s = "", o = 0; o < e.length; o++) s += l.renderItem(e[o], t); r.sc.innerHTML = s, r.updateSC(0) } else r.sc.style.display = "none" }; r.keydownHandler = function (e) { var t = window.event ? e.keyCode : e.which; if ((40 == t || 38 == t) && r.sc.innerHTML) { var s, o = r.sc.querySelector(".autocomplete-suggestion.selected"); return o ? (s = 40 == t ? o.nextSibling : o.previousSibling, s ? (o.className = o.className.replace("selected", ""), s.className += " selected", r.value = s.getAttribute("data-val")) : (o.className = o.className.replace("selected", ""), r.value = r.last_val, s = 0)) : (s = 40 == t ? r.sc.querySelector(".autocomplete-suggestion") : r.sc.childNodes[r.sc.childNodes.length - 1], s.className += " selected", r.value = s.getAttribute("data-val")), r.updateSC(0, s), !1 } if (27 == t) r.value = r.last_val, r.sc.style.display = "none"; else if (13 == t) { var o = r.sc.querySelector(".autocomplete-suggestion.selected"); o && (l.onSelect(e, o.getAttribute("data-val"), o), setTimeout(function () { r.focus(), r.sc.style.display = "none" }, 10)) } }, o(r, "keydown", r.keydownHandler), r.keyupHandler = function (e) { var t = window.event ? e.keyCode : e.which; if (27 != t && 38 != t && 40 != t && 37 != t && 39 != t) { var s = r.value; if (s.length >= l.minChars) { if (s != r.last_val) { if (r.last_val = s, clearTimeout(r.timer), l.cache) { if (s in r.cache) return void d(r.cache[s]); for (var o = 1; o < s.length - l.minChars; o++) { var n = s.slice(0, s.length - o); if (n in r.cache && !r.cache[n].length) return void d([]) } } r.timer = setTimeout(function () { l.source(s, d) }, l.delay) } } else r.last_val = s, r.sc.style.display = "none" } }, o(r, "keyup", r.keyupHandler) } this.destroy = function () { for (var e = 0; e < u.length; e++) { var t = u[e]; n(window, "resize", t.updateSC), n(t, "blur", t.blurHandler), n(t, "focus", t.focusHandler), n(t, "keydown", t.keydownHandler), n(t, "keyup", t.keyupHandler), t.autocompleteAttr ? t.setAttribute("autocomplete", t.autocompleteAttr) : t.removeAttribute("autocomplete"), document.body.removeChild(t.sc), t = null } } } } return e }(); !function () { "function" == typeof define && define.amd ? define("autoComplete", function () { return autoComplete }) : "undefined" != typeof module && module.exports ? module.exports = autoComplete : window.autoComplete = autoComplete }();